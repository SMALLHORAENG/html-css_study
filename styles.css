/* h1{
    color: yellowgreen;
    text-decoration-line: underline;
    font-weight: 800;
    font-size: 20px;
    font-style: italic;
    text-align: center; */
    /* decoration-line 줄 , weight 굵기, style 효과(기울기) */

}

/* body{
    background-color: whitesmoke;
    margin: auto; 
    padding: 20px; */

    /* display: flex;
    height: 100vh;
    align-items: center;
    justify-content: center;
    flex-direction: column;
} */

    /* inline 요소옆에 이어서 배치가능 block 는 요소옆에 이어서 배치 불가능 
    block는 높이와 너비가 있고 inline은 높이 너비가 없음*/
    /* collapsing margins 현상은 안쪽 박스와 바깥 박스의 경계선이 만나면
    위 아래만 같은 margin 값을 갖게되는 현상이 생김 
    겹치지 않게 하기위해선 padding을 사용해주면 됨 */

/* .tomato{
    background-color: tomato;
}
.btn{
    border-radius: 5px;
} */

    /* inline-block는 요소 사이에 빈 공간이 있고 정해진 형식이 없음
    단 사이즈 조절이 가능하고 block로 인식해서 옆에다 다른요소 두는 것 가능
    창 크기가 달라지면 영향을 받음 주로 안쓰는 방법임 */
/* 
body{
    margin: 20px;
    display: flex;
    justify-content: space-evenly;
    align-items: center;
    height: 100vh; 
    flex-direction: column;
    flex-wrap: nowrap;
} */
/* div{  */
    /* position: fixed; */
    /* postion: fixed는 화면을 드래그해도 동일한 위치에서 움직임x
    처음 그려진 위치에서 고정됨 (다른박스 아래에 생성되서 고정하면 그상태로 유지)
    위치는 코드를 수정해서 변경가능  */

    /* position: ; */

    /* width: 150px;
    height: 150px;
    background-color: wheat;
} */

/* .green{
    position: absolute;
    /* relative는 처음 정해진 element를 기준으로 이동가능 
    absolute의 경우는 가장 가까운 relative(부모)를 기준으로 옮겨짐
    div가 아닌 body를 기준으로 옮겨지는 상황임(부모를 position 안했기 때문)*/

   /* top: 0px;
    left: 0px;
    background-color: wheat;
    height: 100px;
    width: 100px;
} */


/* flexbox는 어떤 곳이든 둘 수 있음 그리고 유연함 2차원 레이아웃에 잘 작동함
단 규칙이 있음 자식 엘리먼트에는 어떤 것도 적지 말아야 함 부모 엘리먼트에만 가능
부모 엘리먼트를 flex container로 만들어야 함 (부모 엘리먼트에 display:flex;)
justify-content를 이용해 화면에 위치 지정하고 크기에 맞게 박스크기 조절 됨
flexbox에서 주축인 main axis는 수평 교차축인 cross axis는 수직 (디폴트 값)
justify-content는 주축 위에서 움직임
align-items는 교차축 위에서 움직임 (stretch는 height값이 없어야 적용됨)
flex-direction을 이용하여 수평과 수직을 변경가능 flex의 디폴트는 row(수평)
column값으로 바꾸면 aligh-items의 효과는 주축에 적용됨
자식 엘리먼트안에 요소가 들어갈 때 display:flex를 이용해서 요소위치 변경가능
부모 안에 부모 그리고 자식이 생기는 것
wrap를 nowrap로 하면 요소가 아래로 내려가지 않음 wrap로 하면 화면크기에 맞게 내려감
row-reverse는 순서가 123이 아닌 321로 가도록 하고 row와 column을 수직 수평 정할 수 있음
wrap와direction둘다 이용가능
*/



/* div:first-child{
    background-color: tomato;
}
div:last-child{
    background-color: teal;
} */



/* span:nth-child(2){
    background-color: teal;
}
span:nth-child(4){
    background-color: teal;
} */

/* span:nth-child(odd) {
    background-color: teal;
} */

/* span:nth-child(2n+1){
    background-color: teal;
} */
/*  pseudo selectors / class , id 를 만드는 방법보다 좋음
    even은 짝수를 의미함 반대로 odd는 홀수를 의미함
    2n+1의 경우 2개째마다 바뀜(3n+1은 3개째) */




/* span{
    color: tomato;
    background-color: yellowgreen ;
} */

/* div > span{
    text-decoration-line: underline;
    background-color: yellowgreen;
} */

/* p span{
    color: teal;
} */

/* div p span{
    color: teal;
}
p + span{
    color: blue;
    text-decoration-line: underline;
} */

/* Combinators 클래스(부모안에 있는 자식) 
   div p span은 div안에 p안에 span을 의미하고
   div > span은 바로아래 자식에게만 적용할 때 사용함 div속에 span이 두개인 경우 사용
   >가 아닌 +는 다음 것 지정 div > span은 바로 밑 자식 +는 다음 형제느낌
   형제 바로 뒤 오지않으면 +는 적용 안됨
   그래서 나온것이 "~" 형제와 형제관계 바로 뒤에 올 필요없음
   */



/* input:required{
    border: 1px solid tomato;
}
input:optional{
    border: 1px solid wheat;
}  */

/* input{
    border: 1px solid wheat;
}
input:required{
    border-color: tomato; 
}
input[type="password"] {
    background-color: thistle;
}
input[placeholder~="name"]{
    background-color: pink;
} */

/*  pseudo selector 두번째  <의사 클래스 (의사코드)
    required는 input에서 사용하고 input에 넣어줘서 필수 요소로 지정
    optional은 비어있어도 채워져있어도 동일한 상태
    attribute를 통해 input에서 type가 password인 모든 element에 background-color 적용
    type를 placeholder로 바꿔도 적용됨
    ~=의 경우 "name"이 placeholder에 포함되면 배경 색 바꿈 
    $=의 경우는 뭐뭐로 끝나는 경우
*/



/* button:active{
    background-color: tomato;
}
button:hover{
    background-color: tomato;
}
button:focus{
    background-color: tomato;
}
a:visited{
    color: tomato;
} */

/* form{
    border: 1px solid teal;
    display: flex;
    padding: 20px;
    flex-direction: column;
}
form:focus-within{
    border-color: turquoise;
} */

/* form:hover input{
    background-color: hotpink;
} */

/* form:hover input:focus{
    background-color: teal;
} */

/* state
    active(버튼 클릭하고 있을 때 배경색 가짐) 
    hover(마우스가 올라가면 바뀜 - 배경색과 기존 모양)
    focus(키보드로 선택 됐을 때 배경색 가짐)
    visited( *링크에만 적용 됨* 클릭한 링크의 색 바꿈)
    focus-within(은 focused인 자식을 가진 부모 element에 적용됨)
    state는 다른 엘리먼트와도 연계 가능한데 방법은
    form:hover input{ form이 hover하면 input를 {}안에 있는 내용적용 }
    단 form안에 input이 있어야 함
    두번째 연계방법
    form:hover input:focus{ 위 내용과 다르게 form안에 input이 focus되면 적용됨 }
    * hover도 있기 때문에 마우스도 안에 들어가야 적용 됨 즉 조건이 3개 *
*/



    /* input::placeholder{
        color: yellowgreen;
    }

    p::selection{
        color: teal;
        background-color: yellowgreen;
    }
    p::first-letter{
        background-color: yellow;
        color: teal;
    } */

    /*  Recap
        ::placeholder는 placeholder을 스타일 할 수 있도록 해줌
        ::을 넣어주면 스타일 해줄 수 있음
        selection
        드래그해서 선택하면 안에있는 옵션값으로 바뀜 ex)background-color: yellow
        ::first-letter
        첫번째 글자만 스타일을 해줄 때 사용
        ::first-line
        첫째줄에 적용되는 스타일
    */

    
    

    /* p{
        color: yellow;
        color: #fcce00;
        color: rgb(252, 206, 0);
        background-color: rgba(252, 206, 0, 0.5);
    } */

    /* :root {
        --main-color: #fcce00;
        --default-border: 5px solid var(--main-color);
    }

    p{
        background-color: wheat;
        border: var(--default-border);
    }
    a{
        border: var(--default-border);
        color: var(--main-color);
    } */

    /* color
    color picker 크롬 익스텐션을 이용하여 웹페이지 컬러코드 복사 가능
    color를 넣는 방식은 이름, #코드, rgb, rgba a는 투명도를 의미하는 알파 rgb는
    레드 그린 블루를 의미함

    custom properties (root)
    :root 대부분의 root(출발점같은 개념)
    --main-color: #fcce00 은 컬러를 변수에 저장하는 것 (custom property)라고 부름
    사용할 때 var을 사용해주면 됨
    컬러 외에도 --default-border: 1px solid var(--main-color);도 가능
    */



    /* a{
        color: wheat;
        background-color: tomato;
        text-decoration: none;
        padding: 3px 5px;
        border-radius: 5px;
        font-size: large;
        transition: all 1s cubic-bezier(0.785, 0.135, 0.150, 0.860)
        ,border-radius 5s ease-in-out;
    }
    a:hover{
        border-radius: 5px;
        color: tomato;
        background-color: wheat;
    }

    img{
        border: 5px solid black;
        border-radius: 50%;
        /* transform: rotateY(80deg) rotateX(20deg) rotateZ(10deg);
        transform: scale(2,2);
        transform: translateX(-60px); */
        /* transition: transform 2s ease-in-out; 
    }

    img:hover{
        transform: rotateY(360deg) scale(0.5);
    } */

    /* Transitions 
    hover(state)가 없는 곳에 써야함 - root에 있어야 함 원래 element
    background-color가 변하는 부분이기 때문에 transition부분을 동일하게 한 것
    transition: background-color 10s ease-in-out ,color 5s ease-in-out;
    위와같이 background-color과 color둘 모두에게 효과를 각 각 줄수가 있음
    all을 이용해 모두 다 변하게 할 수 있음 
    ( 효과를 주고싶은 값은 state인 hover안에 
    root인 element와 같은 property를 넣어줘야 함 
    ex. color에 효과 적용시 state 안에도 color이 들어가야 함 )


    part two
    else-in-out는 else-in function 애니메이션이 어떻게 변할지 알려주는 것
    디폴트 값으로는 linear, ease-in, ease-in-out, ease-out, ease
    ( https://matthewlein.com/tools/ceaser 애니메이션 주소)
    cubic-bezier(?.???, ?.???, ?.???, ?.???); 를 이용하여 나만의 애니메이션 생성ㅇ
    
    Transformations (transform mdn)
    transform: rotateY(80deg)는 3D로 80도 돌렸다는 의미 X와Z도 돌릴 수 있음
    scale의 경우는 X와Y의 값을 정해서 크기를 배로 키우게 가능
    translate의 경우 X와Y 값을 정해서 위치 변동이 가능한데 margin padding의 영향X
    state와 함께쓰면 효과가 둘 다 함께 적용됨
    Transitions와 함께쓰면 더욱 좋은효과 낼 수 있음
    */


/* 
    @keyframes CoinFlip{
        from{
            transform: rotateX(0);
        }
        to{
            transform: rotateX(360deg) translateX(100px);
        }
    } */
    /* img{
        border: 10px solid black;
        border-radius: 50%;

        animation: CoinFlip 5s ease-in-out infinite;
        /* animation-iteration-count: infinite; */

        /* opacity: 0px;
        } */

    /* @keyframes CoinFlip{
        0%{
            transform: rotateY(0);
        }
        25%{
            transform: scale(2);
            border-radius: 0px;
        }
        50%{
            transform: rotateY(180deg) translateY(100px);
            border-color: tomato;
        }
        75%{
            transform: scale(5);
            border-radius: 20px;

        }
        100%{
            transform: rotateY(0) translateY(0px);
        }
    } */

    /*Animation (https://animista.net/)
    
    @keyframes CoinFlip{
        from{
            transform: rotateX(0);
        }
        to{
            transform: rotateX(360deg);
        }
    }
    0부터 360도까지 돌게됨, CoinFlip라는 애니메이션 이름 정함
        img{
        border: 10px solid black;
        border-radius: 50%;
        animation: CoinFlip 5s ease-in-out;
    }
    animation 을 5초간 실시함 마우스를 올리지 않아도 페이지가 로드되면 자동
    + infinite를 이용시 5초간 실행된 것 계속 재생됨

    form과 to를 없애고 0 50 100 퍼센트로 하면 시작 중간 끝 나뉨
    */



    /* div{
        background-color: teal;
        width: 200px;
        height: 200px;
        
    } */
    /* @media screen and (min-width: 650px) and (max-width: 750px)*/
    /* @media screen and (max-width:600px){
        div{
            background-color: tomato;
        }
    } */
    /* @media screen and (min-device-width:601px) and (max-width:1200px)
    and (orientation : landscape){
        div{
            background-color: wheat;
        }
    }
    span{
        font-size: 36px;
    }
    @media screen and (orientation : landscape){
        span{
        display: none;
        }
    } */
    /* @media screen and (min-width:1200px){
        div{
            background-color: turquoise;
        }
    } */

    /* Media Queries(media query)
    @media screen and (max-width: 400px){}는 화면크기가 400px보다 작을시 라는 조건
    @media screen and (min-width: 650px) and (max-width: 750px)
    위 조건은 650px~750px의 width값을 가질 시 적용되는 조건

    (orientation : landscape) 이 조건은 세로모드인지 가로모드인지 구별가능
    landscape는 가로모드, portrait는 세로모드 (가로세로 감지)
    뷰포트 즉 보이는 상태를 감지

    span{
        font-size: 36px;
    }
    @media screen and( orientation : landscape){
        span{
        display: none;
        }
    }
    span의 폰트는 36px이고 screen이 가로로 감지되면 span의 display는 none가 된다
    (span을 보여주지 않는다 즉 텍스트가 보이지 않음)

    and를 쓰고 꼭 띄워주자(조건과 and를 꼭 띄워서 써줘야 인식잘됨) 
    크롬 우클릭 후 검사를 눌러 핸드폰 화면테스트가 가능하다
    좌측상단 스마트폰 모양버튼 눌러서 사용
    
    and는 값이 참이라면 실행시켜줌, element에 css를 적용해줘야 함
    예를들어 위 코드에 span{display: none;}에 span이 없으면 안된다는 소리
    and를 이용하여 조건을 연결함
    media query는 핸드폰에만 적용됨 브라우저는 이해하지 못함
    min-device-width로도 사용이 가능함
    Css media query Mdn를 검색해서 이용 가능한 query 탐색 */

    /* @media print{
        body{
            background-color: tomato;
        }
    } */

    /*
    *aspect-ratio를 이용하여 스크린과 레티나 디스플레이 구분 아이폰과 Mac Os*
    레티나 디스플레이면 더 나은 퀄리티의 화면 보여줄 수 있음

    *media type*
    screen 말 그대로 스크린(화면)
    print  인쇄 미리보기 화면에 표시됨 (배경 그래픽 선택시 변경된 것 보임)

    /* GIT, GITHUB
    git를 사용시 파일의 변경내용을 확인 가능함 
    git은 파일을 binary format으로 인식 (0010101010001)
    git은 파일을 게속 추적하는것

    github는 변경내용을 업로드
    git은 파일의 변경내용 계속 추적해주는 version control system이고
    github는 파일 내용과 파일들을 올려주는 공간
    git-scm.com을 들어가서 다운로드 가능

    github Repository(Repositories) 저장소
    내 코드를 넣을 폴더 코드의 변경내역과 히스토리 갖고 있는 폴더
    private는 비공개 public는 공개
    history를 통해서 파일의 변경정보 확인가능
    commit는 시점을 의미 (저장을 한 시점)
    이전코드는 빨간색의 배경을 하고 -표시된 코드
    변경된 코드는 초록색 배경을 하고 +표시된 코드
    commit이름을 정해서 저장해줘도 좋음(기록에 남기때문)

    new버튼 -> owner은 계정선택 -> repository name은 공백없이 소문자로 작성
    -> description(설명) 적고 public와 private중 선택
    -> 이외의 설정은 건드리지 않기

    -> 이렇게 repository를 생성한 뒤 github desktop 설치
    -> 로그인 후 Clone a REpository from the internet를 선택하고
    -> 경로지정 (폴더가 없는경우 생성가능)
    -> clone 누르면 폴더가 생성되고 끝 (연결된 것)

    이후 vsc로 폴더를 끌어와서 켜준 뒤 README.md 파일 만들기
    여기서 md라는 확장자는 markdown이며 서식있는 문서를 작성하는것
    readme파일은 모든 git repository가 가지고 있어야되는 파일
    # 부호는 markdown에서 제목을 만들 때 사용
    자세한 내용은 구글에 검색 (markdown tag)

    github desktop보면 파일 수정된 것 확인가능
    publish (게시)
    

    */



   /*여기까지가 이론공부 이후는 실제 클론코딩*/


   





