h1{
    color: yellowgreen;
    text-decoration-line: underline;
    font-weight: 800;
    font-size: 20px;
    font-style: italic;
    text-align: center;
    /* decoration-line 줄 , weight 굵기, style 효과(기울기) */

}

/* body{
    background-color: whitesmoke;
    margin: auto; 
    padding: 20px;
} */

    /* inline 요소옆에 이어서 배치가능 block 는 요소옆에 이어서 배치 불가능 
    block는 높이와 너비가 있고 inline은 높이 너비가 없음*/
    /* collapsing margins 현상은 안쪽 박스와 바깥 박스의 경계선이 만나면
    위 아래만 같은 margin 값을 갖게되는 현상이 생김 
    겹치지 않게 하기위해선 padding을 사용해주면 됨 */

.tomato{
    background-color: tomato;
}
.btn{
    border-radius: 5px;
}

    /* inline-block는 요소 사이에 빈 공간이 있고 정해진 형식이 없음
    단 사이즈 조절이 가능하고 block로 인식해서 옆에다 다른요소 두는 것 가능
    창 크기가 달라지면 영향을 받음 주로 안쓰는 방법임 */
/* 
body{
    margin: 20px;
    display: flex;
    justify-content: space-evenly;
    align-items: center;
    height: 100vh; 
    flex-direction: column;
    flex-wrap: nowrap;
} */
div{ 
    /* position: fixed; */
    /* postion: fixed는 화면을 드래그해도 동일한 위치에서 움직임x
    처음 그려진 위치에서 고정됨 (다른박스 아래에 생성되서 고정하면 그상태로 유지)
    위치는 코드를 수정해서 변경가능  */

    /* position: ; */

    width: 150px;
    height: 150px;
    background-color: wheat;
}

/* .green{
    position: absolute;
    /* relative는 처음 정해진 element를 기준으로 이동가능 
    absolute의 경우는 가장 가까운 relative(부모)를 기준으로 옮겨짐
    div가 아닌 body를 기준으로 옮겨지는 상황임(부모를 position 안했기 때문)*/

   /* top: 0px;
    left: 0px;
    background-color: wheat;
    height: 100px;
    width: 100px;
} */


/* flexbox는 어떤 곳이든 둘 수 있음 그리고 유연함 2차원 레이아웃에 잘 작동함

단 규칙이 있음 자식 엘리먼트에는 어떤 것도 적지 말아야 함 부모 엘리먼트에만 가능
부모 엘리먼트를 flex container로 만들어야 함 (부모 엘리먼트에 display:flex;)
justify-content를 이용해 화면에 위치 지정하고 크기에 맞게 박스크기 조절 됨

flexbox에서 주축인 main axis는 수평 교차축인 cross axis는 수직 (디폴트 값)
justify-content는 주축 위에서 움직임
align-items는 교차축 위에서 움직임 (stretch는 height값이 없어야 적용됨)

flex-direction을 이용하여 수평과 수직을 변경가능 flex의 디폴트는 row(수평)
column값으로 바꾸면 aligh-items의 효과는 주축에 적용됨

자식 엘리먼트안에 요소가 들어갈 때 display:flex를 이용해서 요소위치 변경가능
부모 안에 부모 그리고 자식이 생기는 것

wrap를 nowrap로 하면 요소가 아래로 내려가지 않음 wrap로 하면 화면크기에 맞게 내려감
row-reverse는 순서가 123이 아닌 321로 가도록 하고 row와 column을 수직 수평 정할 수 있음
wrap와direction둘다 이용가능
*/



/* div:first-child{
    background-color: tomato;
}

div:last-child{
    background-color: teal;
} */



/* span:nth-child(2){
    background-color: teal;
}
span:nth-child(4){
    background-color: teal;
} */

/* span:nth-child(odd) {
    background-color: teal;
} */

/* span:nth-child(2n+1){
    background-color: teal;
} */
/*  pseudo selectors / class , id 를 만드는 방법보다 좋음
    even은 짝수를 의미함 반대로 odd는 홀수를 의미함
    2n+1의 경우 2개째마다 바뀜(3n+1은 3개째) */




/* span{
    color: tomato;
    background-color: yellowgreen ;
} */

/* div > span{
    text-decoration-line: underline;
    background-color: yellowgreen;
} */

/* p span{
    color: teal;
} */

/* div p span{
    color: teal;
}

p + span{
    color: blue;
    text-decoration-line: underline;
} */

/* Combinators 클래스(부모안에 있는 자식) 
   div p span은 div안에 p안에 span을 의미하고
   div > span은 바로아래 자식에게만 적용할 때 사용함 div속에 span이 두개인 경우 사용
   >가 아닌 +는 다음 것 지정 div > span은 바로 밑 자식 +는 다음 형제느낌
   형제 바로 뒤 오지않으면 +는 적용 안됨
   그래서 나온것이 "~" 형제와 형제관계 바로 뒤에 올 필요없음
   */


    
/* input:required{
    border: 1px solid tomato;
}
input:optional{
    border: 1px solid wheat;
}  */

/* input{
    border: 1px solid wheat;
}
input:required{
    border-color: tomato; 
}

input[type="password"] {
    background-color: thistle;
}

input[placeholder~="name"]{
    background-color: pink;
} */

/*  pseudo selector 두번째  <의사 클래스 (의사코드)
    required는 input에서 사용하고 input에 넣어줘서 필수 요소로 지정
    optional은 비어있어도 채워져있어도 동일한 상태

    attribute를 통해 input에서 type가 password인 모든 element에 background-color 적용
    type를 placeholder로 바꿔도 적용됨

    ~=의 경우 "name"이 placeholder에 포함되면 배경 색 바꿈 
    $=의 경우는 뭐뭐로 끝나는 경우
*/



/* button:active{
    background-color: tomato;
}
button:hover{
    background-color: tomato;
}
button:focus{
    background-color: tomato;
}

a:visited{
    color: tomato;
} */

/* form{
    border: 1px solid teal;
    display: flex;
    padding: 20px;
    flex-direction: column;
}
form:focus-within{
    border-color: turquoise;
} */

/* form:hover input{
    background-color: hotpink;
} */

/* form:hover input:focus{
    background-color: teal;
} */

/* state
    active(버튼 클릭하고 있을 때 배경색 가짐) 
    hover(마우스가 올라가면 바뀜 - 배경색과 기존 모양)
    focus(키보드로 선택 됐을 때 배경색 가짐)
    visited( *링크에만 적용 됨* 클릭한 링크의 색 바꿈)

    focus-within(은 focused인 자식을 가진 부모 element에 적용됨)

    state는 다른 엘리먼트와도 연계 가능한데 방법은
    form:hover input{ form이 hover하면 input를 {}안에 있는 내용적용 }
    단 form안에 input이 있어야 함

    두번째 연계방법
    form:hover input:focus{ 위 내용과 다르게 form안에 input이 focus되면 적용됨 }
    * hover도 있기 때문에 마우스도 안에 들어가야 적용 됨 즉 조건이 3개 *
*/



    input::placeholder{
        color: yellowgreen;
    }

    p::selection{
        color: teal;
        background-color: yellowgreen;
    }
    p::first-letter{
        background-color: yellow;
        color: teal;
    }

    /*  Recap
        ::placeholder는 placeholder을 스타일 할 수 있도록 해줌
        ::을 넣어주면 스타일 해줄 수 있음

        selection
        드래그해서 선택하면 안에있는 옵션값으로 바뀜 ex)background-color: yellow

        ::first-letter
        첫번째 글자만 스타일을 해줄 때 사용

        ::first-line
        첫째줄에 적용되는 스타일
    */


    


